package iTools::XML::Simple;
use base qw( iTools::XML::Parser Exporter );

@EXPORT_OK = qw( simplexml2hash simplehash2xml );

use Data::Dumper; $Data::Dumper::Indent = 1; # for debugging only
use iTools::File qw( readfile writefile );

use strict;

# === Exports ===============================================================
sub simplexml2hash {
	my %args = @_;

	# --- predeclared stuff ---
	my $xml  = new iTools::XML::Simple;

	# --- process arguments ---
	foreach my $key (keys %args) {
		my $value = $args{$key};

		lc($key) eq 'bodykey' and do { $xml->bodykey($value); next }; # body key
		$key =~ /^(?:Text|XML)$/i and do { $xml->text($value); next }; # XML content
		$key =~ /^(?:File|FileName)$/i and do { $xml->getFile($value); next } # XML file
	}

	# --- error checks ---
	#! TODO: use iTools::Message
	unless ($xml->text) { print STDERR "simplexml2hash: no text available to parse\n"; exit 1 }

	# --- parse the XML ---
	return $xml->parse(Text => $xml->text);
}

sub simplehash2xml {
	my %args = @_;

	# --- predeclared stuff ---
	my $xml  = new iTools::XML::Simple;

	# --- process arguments ---
	foreach my $key (keys %args) {
		my $value = $args{$key};

		lc($key) eq 'indent' and do { $xml->indent($value); next }; # indent type
		lc($key) eq 'bodykey' and do { $xml->bodykey($value); next }; # body key
		$key =~ /^(?:Hash|XML)$/i and do { $xml->hash($value); next }; # hash to be converted
		$key =~ /^(?:File|FileName)$/i and do { $xml->file($value); next } # output file
	}

	# --- error checks ---
	#! TODO: use iTools::Message
	unless ($xml->hash) { print STDERR "simplehashxml: no hash to convert to XML\n"; exit 1 }

	# --- render the XML ---
	my $text = $xml->render($xml->hash);
	writefile($xml->file, $text) if $xml->file;
	return $text
}

# === Accessors =============================================================
sub bodykey { defined $_[1] ? $_[0]->{bodykey} = $_[1] : ($_[0]->{bodykey} || '<body>') }
sub file { defined $_[1] ? $_[0]->{file} = $_[1] : $_[0]->{file} }
sub hash { defined $_[1] ? $_[0]->{hash} = $_[1] : $_[0]->{hash} }
sub indent { defined $_[1] ? $_[0]->{indent} = $_[1] : ($_[0]->{indent} || "\t") }
sub text { defined $_[1] ? $_[0]->{text} = $_[1] : $_[0]->{text} }

# === Utility Methods =======================================================
# --- load a file ---
sub getFile {
	my ($self, $file) = @_;

	# --- error checks ---
	#! TODO: use iTools::Message
	unless ($file) { print STDERR "iTools::XML::Simple->getFile: no filename given\n"; exit 1 }
	unless (-e $file) { print STDERR "iTools::XML::Simple->getFile: invalid file '$file'\n"; exit 1 }

	# --- read the file and set stuff in $self ---
	$self->text(readfile($file));
	return $self->file($file);
}
# --- get tag hash's attributes ---
sub getAttributes {
	my ($self, $hash) = @_;
	return undef unless ref $hash eq 'HASH'; # safety

	# --- generate a hash of attributes ---
	my $rethash = undef;
	foreach my $key (keys %$hash) {
		next if $key eq $self->bodykey; # ignore the body
		$rethash->{$key} = $hash->{$key} unless ref $hash->{$key};
	}
	return $rethash;
}
# --- get tag hash's body ---
sub getBody {
	my ($self, $hash) = @_;
	return undef unless ref $hash eq 'HASH'; # safety

	# --- return the body ---
	return $hash->{$self->bodykey} if exists $hash->{$self->bodykey};
	return undef; # no body found
}
# --- get tag hash's children ---
sub getChildren {
	my ($self, $hash) = @_;
	return undef unless ref $hash eq 'HASH'; # safety

	# --- generate a hash of children ---
	my $rethash = undef;
	foreach my $key (keys %$hash) {
		$rethash->{$key} = $hash->{$key} if ref $hash->{$key};
	}
	return $rethash;
}

# === Convert XML to Hash ===================================================
# --- parse method for subclass ---
sub parse {
   my $self = shift;

	# --- call superclass parse() w/ our handlers ---
	$self->SUPER::parse(@_,
		XMLHandlers => { Init => \&init, Start => \&start, Char => \&char, End => \&end, Final => \&final },
		Object => $self,
	);

	# --- return the hash generated by our handlers ---
	return $self->hash;
}

# --- handlers ---
sub init { $_[0]->{stack} = [] }
sub start {
	my ($self, $name, %args) = @_;

	# --- build new tag structure ---
	my $tag = {};
	foreach my $key (keys %args) { $tag->{$key} = $self->xmlDecode($args{$key}) }

	# --- put the tag on the top of the stack ---
	unshift @{$self->{stack}}, [ $name => $tag ];
}
sub char {
	my ($self, $content) = @_;

	# --- ignore whitespace and comments ---
	$content =~ s/^\s*<!--.*?-->\s*$//smg;  # comments on their own lines
	$content =~ s/<!--.*?-->//sg;           # comments in line with body text

	# --- no content to add (all whitespace will be ignored) ---
	return if $content =~ /^\s*$/s;

	# --- make sure we have a tag to work with ---
	#! TODO: Throw error here
	return unless @{$self->{stack}};

	# --- get tag ---
	my ($name, $tag) = @{$self->{stack}->[0]};

	# --- add body to tag ---
	$tag->{$self->bodykey} = $self->xmlDecode($content);
}
sub end {
	my ($self, $name) = @_;

	# --- make sure we have a tag to work with ---
	#! TODO: Throw error here?  We may not wat to at the topmost level
	return unless @{$self->{stack}} > 1;

	#! TODO: throw an error when tag names are mismatched

	# -- remove child tag from top of stack and get parent ---
	my ($cname, $ctag) = @{shift @{$self->{stack}}};
	my ($pname, $ptag) = @{$self->{stack}->[0]};

	# --- attach the child tag to the parent ---
	if (exists $ptag->{$cname} && defined $ptag->{$cname}) {
		# --- if a tag named 'cname' already exists, make it an array ---
		$ptag->{$cname} = [ $ptag->{$cname} ] unless ref $ptag->{$cname} eq 'ARRAY';
		push @{$ptag->{$cname}}, $ctag;
	} else {
	   $ptag->{$cname} = $ctag;
	}
}
sub final {
	my $self = shift;
	# --- get the last tag and set it as the hash ---
	my ($name, $tag) = @{shift @{$self->{stack}}};
	$self->hash({ $name => $tag });
}

# === Convert Hash to XML ===================================================
sub render {
	my ($self, $xmlhash) = @_;

	# --- get the xml hash (used for non-object calls) ---
	$self->{hash} = $xmlhash if $xmlhash;

	# --- call dump for each of the root level keys ---
	my $text = '';
	foreach my $key (keys %$xmlhash) {
		$text .= $self->_dump($key, $xmlhash->{$key}, 0);
	}

	# --- add the header and return the generated xml ---
	return $self->text(qq[<?xml version="1.0" encoding="UTF-8"?>\n$text]);
}

sub _dump {
	my ($self, $tag, $hash, $depth) = @_;

	# --- predefined stuff ---
	my $text = '';

	# --- this is an array, not a hash, so render a bunch of tags ---
	if (ref $hash eq 'ARRAY') {
		foreach my $element (@$hash) { $text .= $self->_dump($tag, $element, $depth) }
		return $text;
	}

	# --- predefine more stuff ---
	my $attr   = $self->getAttributes($hash) || {};
	my $body   = $self->getBody($hash) || '';
	my $child  = $self->getChildren($hash) || {};
	my $indent = $self->indent x $depth;

	# --- render the tag ---
	$text = "$indent<$tag";
	foreach my $key (keys %$attr) {
		$text .= qq[ $key="]. $self->xmlEncode($attr->{$key}) .'"';
	}

	# --- render the body and children ---
	$body = $self->xmlEncode($body);
	if (%$child) {
		$body = "\n$body" unless $body =~ /^[\r\n]/s;
		$body = "$body\n" unless $body =~ /[\r\n]$/s;
		foreach my $key (keys %$child) {
			$body .= $self->_dump($key, $child->{$key}, $depth + 1);
		}
	}

	# --- combine tag text and body ---
	if ($body eq '') { $text .= "/>\n" }                   # selfending
	elsif (%$child)  { $text .= ">$body$indent</$tag>\n" } # with children
	else             { $text .= ">$body</$tag>\n" }        # all other cases

	# --- return the XML text ---
	return $text;
}

1;

=head1 NAME

iTools::XML::Simple - A Simple XML file parser based on iTools::XML::Parser

=head1 SYNOPSIS

   use iTools::XML::Simple qw( simplexml2hash simplehash2xml );

   my $hash = simplexml2hash(File => 'foo.xml');
   my $xml = simplehashxml(Hash => $hash, File => 'foo.xml');

=head1 DESCRIPTION

iTools' Simple XML parser is an extension of B<iTools::XML::Parser> that converts XML to a simple Perl data structure.
It is used via the exported functions B<simplexml2hash> and B<simplehash2xml>.

An example of how B<iTools::XML::Simple> converts XML text to a datastructure is as follows.
Given the following XML:

  <?xml version="1.0"?>
  <ship name="reddwarf">
    <size>big</size>
	 <!-- what follows is a list of idiots -->
    <crew>
      <rimmer type="git"/>
      <lister type="slob">
        <lovesLager/>
      </lister>
      <computer>
        <name type="dense">holly</name>
        <name>queeg</name>
      </computer>
    </crew>
  </ship>

This data structure is generated:

  { ship => {
      crew => {
        lister => {
          lovesLager => {},
          type => 'slob'
        },
        rimmer => { type => 'git' }
        computer => {
          name => [
            { '<body>' => 'holly', type => 'dense' },
            { '<body>' => 'queeg' }
          ]
        },
      },
      name => 'reddwarf',
      size => { '<body>' => 'big' }
  } }

When converting XML to a datastructure, the following rules are followed:

=over 4

=item * Attributes are stored as B<scalars>

=item * Tag bodies are stored as a B<scalar> using the value set for B<BodyKey> ('<body>' by default)

=item * Children are stored as B<hashref>s

=item * Multiple children by the same name are stored as an B<arrayref> of B<hashref>s

=item * All comments are removed (with some intelligence for whitespace)

=back

=head1 EXPORTS

=over 4

=item B<simplexml2hash>(B<File> => FILE | B<XML> => TEXT, [B<BodyKey> => BODYKEY])

Converts XML to a hash structure.

This function converts a block of XML into a hash structure.
It requires either a string of B<XML> or the name of an XML B<File> as a parameter.
The B<BodyKey> parameter allows you to specify an alternate hash key value a tag's body.

Returns the generated data structure as a hash reference.

=item B<simplehash2xml>(B<Hash> => HASH, [B<File> => FILE,] [B<Indent> => INDENT,] [B<BodyKey> => BODYKEY])

This function converts a data structure into XML text.
The B<Hash> parameter is required.

The B<Indent> parameter specifies an indent string for nested tags.
The B<BodyKey> parameter allows you to specify an alternate hash key value a tag's body.

Returns the generated XML.
If for use the B<File> parameter, the XML will also be written to given filename.

=back

=head1 XML COMPLIANCE

The B<iTools::XML::Simple> is not compliant with the XML 1.0 or 1.1 specification for the following reasons:

=over 4

=item B<Does not maintain tag order>

Due to the use of B<hashref>s and the globbing of tags by the same name through B<arrayref>s, no semblance of tag or attribute order is maintained.
As a result, the generated data structure is not useful where the order of the tags is important.

=item B<Does not always honor whitespace in body>

In general, the body of a tag is taken verbatum, but if you mix comments into the body text, some whitespace munging around the comments may occur.

=back

=head1 TODO

 - add flag to ignore comments?

=head1 REPORTING BUGS

Report bugs in the iTools' issue tracker at
L<https://github.com/iellenberger/itools/issues>

=head1 AUTHORS

Ingmar Ellenberger

=head1 COPYRIGHT

Copyright (c) 2001-2012 by Ingmar Ellenberger and distributed under The Artistic License.
For the text the license, see L<https://github.com/iellenberger/itools/blob/master/LICENSE>
or read the F<LICENSE> in the root of the iTools distribution.

=head1 REQUIRES

Data::Dumper(3) (for debugging only),
Exporter(3),
iTools::File(3),
iTools::XML::Parser(3)

=head1 SEE ALSO

iTools::XML::Parser(3)

=cut
